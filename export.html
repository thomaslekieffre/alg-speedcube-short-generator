<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Twisty Export</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        width: 1080px;
        height: 1920px;
        overflow: hidden;
        position: relative;
      }
      .bg {
        position: absolute;
        inset: 0;
        z-index: 0;
      }
      .scene {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
      }
      twisty-player {
        width: 70vmin;
        height: 70vmin;
      }
      .ovl {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 2;
        pointer-events: none;
        gap: 700px;
      }
      .ovl.visible {
        opacity: 1;
      }
      .name,
      .notation {
        color: #0e0f12;
        background: #fff;
        border-radius: 36px;
        padding: 22px 34px;
        box-shadow: 0 18px 44px rgba(0, 0, 0, 0.5),
          0 6px 16px rgba(0, 0, 0, 0.35);
        text-align: center;
        max-width: 92%;
        transform: translateZ(0);
        text-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
      }
      .name {
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 96px;
        font-weight: 900;
        letter-spacing: 1.5px;
      }
      .notation {
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 90px;
        font-weight: 900;
        letter-spacing: 1.2px;
        line-height: 1.25;
      }
    </style>
  </head>
  <body>
    <div class="bg" id="bg"></div>
    <div class="scene">
      <twisty-player id="tp"></twisty-player>
    </div>
    <div class="ovl" id="ovl">
      <div class="name" id="nameEl"></div>
      <div class="notation" id="notationEl"></div>
    </div>

    <script type="module">
      import "https://cdn.cubing.net/v0/js/cubing/twisty";
      import { Alg } from "https://cdn.cubing.net/v0/js/cubing/alg";

      const params = new URLSearchParams(window.location.search);
      const alg = params.get("alg") || "R U R' U'";
      const name = params.get("name") || "";
      const notation = params.get("notation") || alg;
      const puzzle = params.get("puzzle") || "3x3x3";
      // Vitesses paramétrables
      const speed1 = parseFloat(params.get("speed1") || "1.5"); // lecture 1
      const speedSetup = parseFloat(params.get("speedSetup") || "3.0"); // setup/reverse
      const speed2 = parseFloat(params.get("speed2") || "1.0"); // lecture 2
      const repeats = 1; // on force 1
      const bgParam = params.get("bg") || "";
      const bgImage = "";
      const bgVideo = ""; // désactivé

      function resolveAsset(pathOrUrl) {
        if (!pathOrUrl) return pathOrUrl;
        if (pathOrUrl.startsWith("public/")) {
          return "/" + pathOrUrl.slice(7);
        }
        return pathOrUrl;
      }

      const tp = document.getElementById("tp");
      const bgEl = document.getElementById("bg");
      const ovl = document.getElementById("ovl");
      const nameEl = document.getElementById("nameEl");
      const notationEl = document.getElementById("notationEl");

      function normalize(str) {
        // remplace les apostrophes typographiques par des apostrophes droites
        return str.replace(/[’′]/g, "'");
      }

      function inverse(algStr) {
        try {
          const algObj = new Alg(normalize(algStr));
          return algObj.invert().toString();
        } catch (e) {
          console.error("Erreur inverse:", e);
          return "";
        }
      }

      // Config fond - couleur paramétrable ou aléatoire
      let bgColor;
      if (bgParam) {
        bgColor = bgParam;
        console.log("Fond couleur choisie:", bgColor);
      } else {
        const randomHue = Math.floor(Math.random() * 360);
        bgColor = `hsl(${randomHue}, 70%, 50%)`;
        console.log("Fond couleur aléatoire:", bgColor);
      }
      bgEl.style.background = bgColor;

      // Config overlays
      nameEl.textContent = (name || "").trim();
      notationEl.textContent = (notation || alg).trim();
      // Toujours afficher le nom si fourni
      nameEl.style.display = nameEl.textContent ? "inline-block" : "none";
      // La notation est toujours visible
      notationEl.style.display = "inline-block";

      // Config player
      tp.puzzle = puzzle;
      tp.visualization = "3D";
      tp.renderer = "webgl";
      tp.hintFacelets = "none";
      tp.backView = "none";
      tp.background = "none";
      tp.controlPanel = "none";
      tp.cameraLatitude = 25;
      tp.cameraLongitude = -30;

      async function playOnce(tempo, algStr, setupStr) {
        tp.tempoScale = tempo;
        tp.experimentalSetupAlg = setupStr;
        tp.alg = algStr;
        // Laisser le modèle se synchroniser
        await new Promise((r) =>
          requestAnimationFrame(() => requestAnimationFrame(r))
        );
        console.log("Playing alg:", algStr, "tempo:", tempo);

        // Calculer la durée estimée de l'animation
        const moveCount = algStr
          .split(/\s+/)
          .filter((s) => s.length > 0).length;
        // Durée par mouvement = environ 1000ms à tempo 1.0
        const baseDuration = moveCount * 1000;
        const adjustedDuration = baseDuration / tempo;
        console.log(
          `Durée estimée: ${adjustedDuration}ms pour ${moveCount} mouvements`
        );

        // Lancer l'animation
        await tp.play();
        console.log("Play() returned, attente de la fin réelle...");

        // Attendre la durée complète de l'animation + marge
        await new Promise((r) => setTimeout(r, adjustedDuration + 1500));
        console.log("Fin d'attente");
      }

      async function playN(n, tempo, algStr, setupStr) {
        for (let i = 0; i < n; i++) {
          await playOnce(tempo, algStr, setupStr);
        }
      }

      async function run() {
        window.__exportDone = false;

        try {
          const normalizedAlg = normalize(alg);
          const inv = inverse(normalizedAlg);

          console.log("Alg:", normalizedAlg);
          console.log("Inv:", inv);

          // Overlays visibles dès le début
          ovl.classList.add("visible");
          // Lecture 1: alg complet depuis état brouillé
          console.log(`=== Lecture 1 (x${speed1}) ===`);
          await playOnce(speed1, normalizedAlg, inv);
          console.log("=== Lecture 1 terminée ===");
          // Reset: jouer l'inverse depuis l'état résolu (pas de setup)
          console.log(`=== Reverse pour reset (x${speedSetup}) ===`);
          await playOnce(speedSetup, inverse(normalizedAlg), "");
          console.log("=== Reverse terminé ===");
          // Lecture 2: alg complet depuis état brouillé
          console.log(`=== Lecture 2 (x${speed2}) ===`);
          await playOnce(speed2, normalizedAlg, inv);
          console.log("=== Lecture 2 terminée ===");
          // Marge finale pour capturer les dernières frames
          await new Promise((r) => setTimeout(r, 800));

          window.__exportDone = true;
          console.log("Export terminé");
        } catch (e) {
          console.error("Erreur:", e);
          window.__exportDone = true;
        }
      }

      // Attendre que le player soit initialisé
      async function waitForPlayer() {
        // Attendre que le modèle soit créé
        await tp.experimentalModel;
        // Attendre que le renderer WebGL soit prêt
        if (tp?.experimentalModel?.rendererPromise) {
          await tp.experimentalModel.rendererPromise;
        }
        // Deux frames pour laisser WebGL dessiner
        await new Promise((r) =>
          requestAnimationFrame(() => requestAnimationFrame(r))
        );
        console.log("Player initialisé (WebGL prêt)");
      }

      // Exposer la fonction pour Playwright
      window.__exportReady = false;

      waitForPlayer().then(() => {
        window.__exportReady = true;
      });

      window.startExport = async () => {
        await run();
      };
    </script>
  </body>
</html>
