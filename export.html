<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Twisty Export</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        width: 1080px;
        height: 1920px;
        overflow: hidden;
        position: relative;
      }
      .bg {
        position: absolute;
        inset: 0;
        z-index: 0;
        background-size: 200% 200%;
        animation: bgMove 8s ease-in-out infinite;
        will-change: background-position;
        transform: translateZ(0);
      }
      @keyframes bgMove {
        0% {
          background-position: 0% 0%;
          transform: translateZ(0);
        }
        25% {
          background-position: 100% 0%;
          transform: translateZ(0);
        }
        50% {
          background-position: 100% 100%;
          transform: translateZ(0);
        }
        75% {
          background-position: 0% 100%;
          transform: translateZ(0);
        }
        100% {
          background-position: 0% 0%;
          transform: translateZ(0);
        }
      }
      .scene {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
      }
      twisty-player {
        width: 70vmin;
        height: 70vmin;
        will-change: contents;
        transform: translateZ(0);
      }
      .ovl {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        z-index: 2;
        pointer-events: none;
        gap: 700px;
      }
      .ovl.visible {
        opacity: 1;
      }
      .ovl.transitioning {
        opacity: 0;
        transform: scale(0.95);
      }
      .name,
      .notation {
        color: #0e0f12;
        background: #fff;
        border-radius: 36px;
        padding: 22px 34px;
        box-shadow: 0 18px 44px rgba(0, 0, 0, 0.5),
          0 6px 16px rgba(0, 0, 0, 0.35);
        text-align: center;
        max-width: 92%;
        transform: translateZ(0);
        text-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
        transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
        will-change: transform, opacity;
        backface-visibility: hidden;
      }
      .name.slide-out {
        transform: translateY(-50px);
        opacity: 0;
      }
      .name.slide-in {
        animation: slideInFromTop 0.6s ease-out forwards;
      }
      @keyframes slideInFromTop {
        from {
          transform: translateY(-50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      .name {
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 96px;
        font-weight: 900;
        letter-spacing: 1.5px;
      }
      .name.glow {
        animation: pulse 2s ease-in-out infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          box-shadow: 0 18px 44px rgba(0, 0, 0, 0.5),
            0 6px 16px rgba(0, 0, 0, 0.35);
          transform: translateZ(0) scale(1);
        }
        50% {
          box-shadow: 0 18px 44px rgba(0, 0, 0, 0.5),
            0 6px 16px rgba(0, 0, 0, 0.35), 0 0 40px rgba(255, 255, 255, 0.6),
            0 0 80px rgba(255, 255, 255, 0.3);
          transform: translateZ(0) scale(1.02);
        }
      }
      .notation {
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 90px;
        font-weight: 900;
        letter-spacing: 1.2px;
        line-height: 1.25;
      }
      /* Flash de transition */
      .flash {
        position: fixed;
        inset: 0;
        background: white;
        opacity: 0;
        z-index: 999;
        pointer-events: none;
      }
      .flash.active {
        animation: flashEffect 0.4s ease-out;
      }
      @keyframes flashEffect {
        0% {
          opacity: 0;
        }
        50% {
          opacity: 0.7;
        }
        100% {
          opacity: 0;
        }
      }
      /* Indicateur de vitesse */
      .speed-indicator {
        position: absolute;
        top: 650px;
        right: 60px;
        background: rgba(0, 0, 0, 0.95);
        color: #00ff88;
        padding: 18px 32px;
        border-radius: 32px;
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 64px;
        font-weight: 900;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 3;
        will-change: opacity;
        transform: translateZ(0);
        box-shadow: 0 12px 36px rgba(0, 0, 0, 0.8),
          0 0 40px rgba(255, 255, 255, 0.5);
        border: 4px solid rgba(255, 255, 255, 0.7);
        min-width: 140px;
        text-align: center;
      }
      .speed-indicator.visible {
        opacity: 1;
      }
      /* Compteur de mouvements */
      .move-counter {
        position: absolute;
        top: 650px;
        left: 60px;
        background: rgba(0, 0, 0, 0.95);
        color: #00ff88;
        padding: 18px 32px;
        border-radius: 32px;
        font-family: system-ui, -apple-system, sans-serif;
        font-size: 64px;
        font-weight: 900;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 3;
        will-change: opacity;
        transform: translateZ(0);
        box-shadow: 0 12px 36px rgba(0, 0, 0, 0.8),
          0 0 40px rgba(0, 255, 136, 0.6);
        border: 4px solid rgba(0, 255, 136, 0.8);
        min-width: 140px;
        text-align: center;
      }
      .move-counter.visible {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div class="bg" id="bg"></div>
    <div class="scene">
      <twisty-player id="tp"></twisty-player>
    </div>
    <div class="ovl" id="ovl">
      <div class="name" id="nameEl"></div>
      <div class="notation" id="notationEl"></div>
    </div>
    <div class="flash" id="flash"></div>
    <div class="speed-indicator" id="speedInd">x1.0</div>
    <div class="move-counter" id="moveCounter">0/0</div>

    <script type="module">
      import "https://cdn.cubing.net/v0/js/cubing/twisty";
      import { Alg } from "https://cdn.cubing.net/v0/js/cubing/alg";

      const params = new URLSearchParams(window.location.search);
      const alg = params.get("alg") || "R U R' U'";
      const name = params.get("name") || "";
      const notation = params.get("notation") || alg;
      const puzzle = params.get("puzzle") || "3x3x3";
      // Vitesses paramétrables
      const speed1 = parseFloat(params.get("speed1") || "1.5"); // lecture 1
      const speedSetup = parseFloat(params.get("speedSetup") || "3.0"); // setup/reverse
      const speed2 = parseFloat(params.get("speed2") || "1.0"); // lecture 2
      const repeats = 1; // on force 1
      const bgParam = params.get("bg") || "";
      const bgImage = "";
      const bgVideo = ""; // désactivé
      // Options de transitions
      const enableFlash = params.get("showFlash") === "1";
      const enableGlow = params.get("showGlow") === "1";
      const enableSpeed = params.get("showSpeed") === "1";
      const enableMoves = params.get("showMoves") === "1";

      function resolveAsset(pathOrUrl) {
        if (!pathOrUrl) return pathOrUrl;
        if (pathOrUrl.startsWith("public/")) {
          return "/" + pathOrUrl.slice(7);
        }
        return pathOrUrl;
      }

      const tp = document.getElementById("tp");
      const bgEl = document.getElementById("bg");
      const ovl = document.getElementById("ovl");
      const nameEl = document.getElementById("nameEl");
      const notationEl = document.getElementById("notationEl");
      const flashEl = document.getElementById("flash");
      const speedInd = document.getElementById("speedInd");
      const moveCounter = document.getElementById("moveCounter");

      function normalize(str) {
        // remplace les apostrophes typographiques par des apostrophes droites
        return str.replace(/[’′]/g, "'");
      }

      function inverse(algStr) {
        try {
          const algObj = new Alg(normalize(algStr));
          return algObj.invert().toString();
        } catch (e) {
          console.error("Erreur inverse:", e);
          return "";
        }
      }

      // Config fond - gradient animé paramétrable ou aléatoire
      let bgColor;
      if (bgParam) {
        bgColor = bgParam;
        console.log("Fond couleur choisie:", bgColor);
      } else {
        const randomHue = Math.floor(Math.random() * 360);
        bgColor = `hsl(${randomHue}, 70%, 50%)`;
        console.log("Fond couleur aléatoire:", bgColor);
      }
      // Créer un gradient animé à partir de la couleur de base
      const hue1 = bgParam
        ? extractHue(bgParam)
        : Math.floor(Math.random() * 360);
      const hue2 = (hue1 + 60) % 360; // couleur complémentaire
      const hue3 = (hue1 + 120) % 360;
      bgEl.style.background = `linear-gradient(135deg, hsl(${hue1}, 70%, 50%) 0%, hsl(${hue2}, 70%, 50%) 50%, hsl(${hue3}, 70%, 50%) 100%)`;
      console.log("Gradient animé:", hue1, hue2, hue3);

      function extractHue(hex) {
        // Convertir hex en HSL
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h = 0;
        if (max !== min) {
          const d = max - min;
          if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
          else if (max === g) h = ((b - r) / d + 2) / 6;
          else h = ((r - g) / d + 4) / 6;
        }
        return Math.floor(h * 360);
      }

      // Config overlays
      nameEl.textContent = (name || "").trim();
      notationEl.textContent = (notation || alg).trim();
      // Toujours afficher le nom si fourni
      nameEl.style.display = nameEl.textContent ? "inline-block" : "none";
      // La notation est toujours visible
      notationEl.style.display = "inline-block";
      // Appliquer le glow si activé
      if (enableGlow) {
        nameEl.classList.add("glow");
      }

      // Flash de transition
      async function flash() {
        if (!enableFlash) return;
        flashEl.classList.add("active");
        await new Promise((r) => setTimeout(r, 400));
        flashEl.classList.remove("active");
      }

      // Fonction de transition pour changer le nom
      async function transitionName(newName) {
        nameEl.classList.add("slide-out");
        await new Promise((r) => setTimeout(r, 500));
        nameEl.textContent = newName;
        nameEl.classList.remove("slide-out");
        nameEl.classList.add("slide-in");
        await new Promise((r) => setTimeout(r, 600));
        nameEl.classList.remove("slide-in");
      }

      // Mise à jour du compteur de mouvements
      function updateMoveCounter(current, total) {
        moveCounter.textContent = `${current}/${total}`;
      }

      // Mise à jour de l'indicateur de vitesse
      function updateSpeedIndicator(speed) {
        speedInd.textContent = `x${speed.toFixed(1)}`;
      }

      // Config player
      tp.puzzle = puzzle;
      tp.visualization = "3D";
      tp.renderer = "webgl";
      tp.hintFacelets = "none";
      tp.backView = "none";
      tp.background = "none";
      tp.controlPanel = "none";
      tp.cameraLatitude = 25;
      tp.cameraLongitude = -30;

      async function playOnce(tempo, algStr, setupStr, showCounters = true) {
        tp.tempoScale = tempo;
        tp.experimentalSetupAlg = setupStr;
        tp.alg = algStr;
        // Laisser le modèle se synchroniser
        await new Promise((r) =>
          requestAnimationFrame(() => requestAnimationFrame(r))
        );
        console.log("Playing alg:", algStr, "tempo:", tempo);

        // Calculer la durée estimée de l'animation
        const moveCount = algStr
          .split(/\s+/)
          .filter((s) => s.length > 0).length;
        // Durée par mouvement = environ 1000ms à tempo 1.0
        const baseDuration = moveCount * 1000;
        const adjustedDuration = baseDuration / tempo;
        console.log(
          `Durée estimée: ${adjustedDuration}ms pour ${moveCount} mouvements`
        );

        // Afficher les indicateurs
        if (showCounters && enableSpeed) {
          updateSpeedIndicator(tempo);
          speedInd.classList.add("visible");
        }
        if (showCounters && enableMoves) {
          updateMoveCounter(0, moveCount); // initialiser à 0/total
          moveCounter.classList.add("visible");
        }

        // Lancer l'animation
        await tp.play();
        console.log("Play() returned, attente de la fin réelle...");

        // Lancer l'animation et attendre
        const startTime = Date.now();
        let rafId;

        // Simuler le compteur de mouvements pendant l'animation (optimisé avec rAF)
        if (showCounters && enableMoves) {
          const animateCounter = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / adjustedDuration);
            const currentMove = Math.min(
              moveCount,
              Math.floor(progress * moveCount) + 1
            );
            updateMoveCounter(currentMove, moveCount);
            if (elapsed < adjustedDuration + 1500) {
              rafId = requestAnimationFrame(animateCounter);
            }
          };
          rafId = requestAnimationFrame(animateCounter);
        }

        // Attendre la durée complète de l'animation + marge
        await new Promise((r) => setTimeout(r, adjustedDuration + 1500));

        // Nettoyer
        if (rafId) cancelAnimationFrame(rafId);
        if (showCounters && enableMoves) {
          updateMoveCounter(moveCount, moveCount);
        }

        console.log("Fin d'attente");
      }

      async function playN(n, tempo, algStr, setupStr) {
        for (let i = 0; i < n; i++) {
          await playOnce(tempo, algStr, setupStr);
        }
      }

      async function run() {
        window.__exportDone = false;

        try {
          const normalizedAlg = normalize(alg);
          const inv = inverse(normalizedAlg);

          console.log("Alg:", normalizedAlg);
          console.log("Inv:", inv);

          // Lecture 1: alg complet depuis état brouillé avec nom normal
          console.log(`=== Lecture 1 (x${speed1}) ===`);
          ovl.classList.add("visible");
          await playOnce(speed1, normalizedAlg, inv, true);
          console.log("=== Lecture 1 terminée ===");

          // Flash + Transition vers SETUP
          await flash();
          speedInd.classList.remove("visible");
          moveCounter.classList.remove("visible");
          await transitionName("SETUP");

          // Reset: jouer l'inverse depuis l'état résolu avec "SETUP" affiché
          console.log(`=== Reverse pour reset (x${speedSetup}) ===`);
          await playOnce(speedSetup, inverse(normalizedAlg), "", true);
          console.log("=== Reverse terminé ===");

          // Flash + Transition vers nom normal
          await flash();
          speedInd.classList.remove("visible");
          moveCounter.classList.remove("visible");
          await transitionName((name || "").trim());

          // Lecture 2: alg complet depuis état brouillé avec nom normal
          console.log(`=== Lecture 2 (x${speed2}) ===`);
          await playOnce(speed2, normalizedAlg, inv, true);
          console.log("=== Lecture 2 terminée ===");

          // Cacher les indicateurs à la fin
          speedInd.classList.remove("visible");
          moveCounter.classList.remove("visible");
          // Marge finale pour capturer les dernières frames
          await new Promise((r) => setTimeout(r, 800));

          window.__exportDone = true;
          console.log("Export terminé");
        } catch (e) {
          console.error("Erreur:", e);
          window.__exportDone = true;
        }
      }

      // Attendre que le player soit initialisé
      async function waitForPlayer() {
        // Attendre que le modèle soit créé
        await tp.experimentalModel;
        // Attendre que le renderer WebGL soit prêt
        if (tp?.experimentalModel?.rendererPromise) {
          await tp.experimentalModel.rendererPromise;
        }
        // Deux frames pour laisser WebGL dessiner
        await new Promise((r) =>
          requestAnimationFrame(() => requestAnimationFrame(r))
        );
        console.log("Player initialisé (WebGL prêt)");
      }

      // Exposer la fonction pour Playwright
      window.__exportReady = false;

      waitForPlayer().then(() => {
        window.__exportReady = true;
      });

      window.startExport = async () => {
        await run();
      };
    </script>
  </body>
</html>
